\documentclass[12pt, a4paper, oneside]{ctexart}
\usepackage{amsmath, amsthm, amssymb, bm, graphicx, hyperref, mathrsfs, listings}

\title{\textbf{Final: 拉普拉斯求解器}}

\linespread{1.5}
\begin{document}

\maketitle

\section{介绍}
\subsection{有限元方法的基本设置}
这是我们第一个实际使用有限元计算的例子。我们将求解一个边界值为零但右边不为零的泊松方程的简化版本: 
$$\begin{aligned}
    -\Delta u & =f & \text { in } \Omega, \\
    u & =0 & \text { on } \partial \Omega .
    \end{aligned}$$
我们将在正方形域$\Omega=[-1,1]^2$ 上求解该方程, 你已经在step-1 和step-2 中学习了如何生成网格。在本教程中, 我们将只考虑$f(x)=1$的特殊情况, 在下一个教程步骤4中, 我们将讨论如何实现更一般的情况。\\
如果你已经学习过有限元方法的基础知识, 你应该还记得通过有限维近似求解 $u$ 的步骤。具体来说, 我们首先需要推导出上述方程的弱形式, 将方程左边乘以检验函数$\varphi$(下面我们将讨论从左边乘而不是从右边乘的原因), 然后在域Ω上进行积分: 
$$-\int_{\Omega}\varphi \Delta u =\int_{\Omega}\varphi f . $$
可以分部积分: 
$$\int_{\Omega}\nabla \varphi\cdot \nabla u-\int_{\partial\Omega}\varphi \mathrm{n}\cdot\nabla u=\int_{\Omega}\varphi f . $$
测试函数$\varphi$必须满足同样的边界条件(用数学术语来说: 它需要来自我们所寻求解的集合的切空间), 因此在边界上$\varphi =0 $
, 因此我们要寻找的弱形式为: 
$$(\nabla \varphi ,\nabla u)=(\varphi ,f)$$
其中, 我们使用常用标识$(a,b)=\int_{\Omega}a b$然后, 问题就变成从适当的空间(这里是空间 $H^1$)中找出一个函数$u$, 对于所有测试函数 $\varphi$ 上式都成立。\\
当然, 在一般情况下, 我们无法在计算机上找到这样的函数, 因此我们寻求近似值$u_h(x)=\Sigma_j U_j\varphi_j(x)$, 其中$U_j$是我们需要确定的未知膨胀系数(即本问题的 "自由度"), $\varphi_j(x)$是我们将使用的有限元形状函数。为了定义这些形状函数, 我们需要以下几点: 
\begin{itemize}
    \item[$\bullet$]一个用来定义形状函数的网格。你已经看到如何在step-1和step-2中生成和操作描述网格的对象。
    \item[$\bullet$]一个描述我们想在参考单元上使用的形状函数的有限元(在deal.II中, 它总是单位间隔$[0,1]$, 单位正方形$[0,1]^2$或单位立方体$[0,1]^3$, 取决于你在哪个空间维度计算)。 \\
    在step-2中, 我们已经使用了FE\_Q<2>类型的对象,     它表示通常的拉格朗日单元, 通过在支持点上插值定义形状函数。    最简单的是FE\_Q<2>(1),它使用1次多项式。在2d中, 这些通常被称为双线性, 因为它们在参考单元的两个坐标中都是线性的。(在1d中, 它们是线性的, 在3d中是三线性的；然而, 在deal.II文档中, 我们一般不做这种区分, 而只是简单地将这些函数称为"线性")。
    \item[$\bullet$]以有限元对象提供的参考单元描述为基础, 枚举网格上所有自由度的 DoFHandler 对象。你已经在step-2中了解了如何实现该功能。
    \item[$\bullet$] 实单元上的形状函数与参考单元上有限元类定义的形状函数的映射关系。默认情况下, 除非明确说明, 否则deal.II将使用(双、三)线性映射, 因此在大多数情况下, 你不必担心这一步。


\end{itemize}
通过以上这些步骤, 我们现在有了一组函数 $\varphi_i$, 我们可以定义离散问题的弱形式: 找到一个函数 $u_h$, 即找到上面提到的扩展系数 $U_j$, 使得
$$(\nabla \varphi_i,\nabla u_h)=(\varphi_i,f),\qquad i=0\cdots N-1$$
请注意, 我们在这里遵循C和C++中的惯例, 即一切都从零开始计算。如果将$ u_h(x)$表示为$u_h(x)=\Sigma_jU_j\varphi_j(x)$, 这个方程可以被改为一个线性系统: 
$$\begin{aligned}
    \left(\nabla \phi_i, \nabla u_h\right) & =\left(\nabla \phi_i, \nabla\left[\sum_j U_j \phi_j\right]\right) \\
    & =\sum_j\left(\nabla \phi_i, \nabla\left[U_j \phi_j\right]\right) \\
    & =\sum_j\left(\nabla \phi_i, \nabla \phi_j\right) U_j
    \end{aligned}$$
故, 问题转变为: 找到一个向量$U$, 使得
$$AU=F$$
其中矩阵$A$和等式右边$F$定义如下

$$\begin{aligned}
    A_{i j} & =\left(\nabla \varphi_i, \nabla \varphi_j\right), \\
    F_i & =\left(\varphi_i, f\right) .
    \end{aligned}$$
\subsection{我们是应该在等式左边还是右边乘以一个测试函数?}
在我们继续描述如何计算这些量之前, 请注意, 如果我们将原始方程从右边乘以测试函数, 而不是从左边乘以测试函数, 那么我们将得到一个线性系统, 其形式为

$$ U^TA=F^T$$
有一个行向量$F^T$。通过转置这个系统, 这当然等价于求解

$$ATU=F$$
由于$A=A^T$, 这里与上面相同。\\
但一般情况下并非如此, 为了避免任何形式的混淆, 经验表明只要有从左边而不是从右边乘方程的习惯(数学文献中经常这样做), 就可以避免一类常见的错误, 因为矩阵会自动正确, 在比较理论和实现时不需要转置。本教程的第一个示例参见step-9, 我们有一个非对称的双线性方程, 从右边乘还是从左边法是不同的。
\subsection{组装矩阵和右侧向量}
现在我们知道我们需要什么(即: 保存矩阵和矢量的对象, 以及计算$A_{ij},F_{i}$的方法), 我们看看需要什么来实现这一点: 
\begin{itemize}
    \item[$\bullet$]$A$的对象类型为SparseMatrix, 而$U$和$F$的对象类型为Vector。我们将在下面的程序中看到哪些类用于求解线性系统。
    \item[$\bullet$]我们需要一种形成积分的方法。在有限元方法中, 最常用的方法是正交, 即用每个单元上一组正交点的加权和来代替积分。也就是说, 我们首先将$\Omega$上的积分拆分为所有单元上的积分,
    $$
    \begin{aligned}
    A_{i j} & =\left(\nabla \varphi_i, \nabla \varphi_j\right)=\sum_{K \in \mathbb{T}} \int_K \nabla \varphi_i \cdot \nabla \varphi_j, \\
    F_i & =\left(\varphi_i, f\right)=\sum_{K \in \mathbb{T}} \int_K \varphi_i f
    \end{aligned}
    $$
    然后通过正交对每个单元的贡献进行近似计算: 
    $$
    \begin{aligned}
    A_{i j}^K & =\int_K \nabla \varphi_i \cdot \nabla \varphi_j \approx \sum_q \nabla \varphi_i\left(\mathbf{x}_q^K\right) \cdot \nabla \varphi_j\left(\mathbf{x}_q^K\right) w_q^K \\
    F_i^K & =\int_K \varphi_i f \approx \sum_q \varphi_i\left(\mathbf{x}_q^K\right) f\left(\mathbf{x}_q^K\right) w_q^K
    \end{aligned}
    $$
    其中$\mathbb{T}=\Omega$是近似域的三角剖分, $\mathbf{x}_q^K$是单元$K$上的第$q$个正交点, $w_q^K$ 表示第 $q$ 个正交权重。我们将依次讨论不同的部分。
    \item[$\bullet$]首先, 我们需要一种方法来描述正交点的位置 $x_q^K$ 及其权重 $w_q^K$。它们通常以与形状函数相同的方式从参考单元映射, 即使用 MappingQ1 类隐式映射, 或者, 如果你明确说明, 则通过从 Mapping 派生的其他类之一进行映射。参考单元上的位置和权重由从正交基类派生的对象描述。通常情况下, 选择一个正交公式(即一组点和权重), 使正交正好等于矩阵中的积分；由于积分中的所有因子都是多项式, 因此可以实现这一点, 这可以通过QGauss类中实现的高斯正交公式来实现。
    \item[$\bullet$]因此, 我们需要能够帮助我们在单元$K$上评估$\varphi_i(x_q^K)$的东西。这就是FEValues类的作用: 它使用一个有限元对象来描述参考单元上的φ, 使用一个正交对象来描述正交点和权重, 使用一个映射对象(或隐含使用MappingQ1类)来提供实单元K上形状函数的值和导数, 以及在$K$上的正交点进行积分所需的其他各种信息。
    

\end{itemize}
计算矩阵和等式右边作为所有单元的总和(然后是正交点的总和)的过程通常称为组装线性系统, 或简称为组装, 该词的含义与流水线有关, 意为 "将一组碎片、片段或元素组装在一起的行为"。\\
FEValues是装配过程中的核心类。你可以从以下角度来看待它:  FiniteElement和派生类描述形状函数, 即无限维对象: 函数在每一点都有值。出于理论原因, 我们需要这样做, 因为我们希望通过对函数的积分来进行分析。然而, 对于计算机来说, 这是一个非常困难的概念, 因为计算机一般只能处理有限的信息量,  因此我们用正交点上的和来代替积分, 正交点是通过将参考单元上定义的点(正交对象)映射(映射 对象)到实际单元上的点而得到的。从本质上讲, 我们将问题简化为只需要有限信息量的问题, 即形状函数值和导数、正交权重、法向量等, 这些信息只存在于有限的点上。FEValues类将这三个部分结合在一起, 并提供特定单元$K$上的有限信息集。\\
值得注意的是, 如果你只需在应用程序中创建这三个对象, 并自己处理这些信息, 也可以实现所有这些功能。然而, 这样做既不会更简单(FEValues类提供的正是你实际需要的信息), 也不会更快: FEValues类经过高度优化, 只在每个单元格中计算你需要的特定信息；如果可以重复使用上一个单元格中的任何信息, 它就会这样做, 而且该类中有大量代码确保在有利的情况下缓存信息。\\
最后要提到的是, 在得到线性系统后, 我们使用迭代求解器对其进行求解, 然后进行后处理: 我们使用DataOut类创建输出文件, 然后可以使用常见的可视化程序对其进行可视化。

\subsection{求解线性系统}
对于有限元程序来说, 这里的线性系统相对较小: 矩阵大小为1089×1089, 因为我们使用的网格是32×32, 所以网格中有$33^2=1089$个顶点。在后面的教程中, 矩阵大小在几万到几十万之间的情况并不少见, 在deal.II基础上开发的ASPECT等代码中, 我们经常求解超过一亿个方程的问题(尽管使用的是并行计算机)。无论如何, 即使是这里的小系统, 矩阵也比本科生或大多数研究生课程中通常遇到的大得多, 因此问题来了, 我们如何解决这样的线性系统。

我们通常学习的第一种求解线性系统的方法是高斯消元法。这种方法的问题在于它需要的运算次数与$N^3$成正比, 其中$N$是线性系统中的方程或未知数的个数--更具体地说, 运算次数大约为$\frac{2}{3}N^3$。在$N=1089$的情况下, 这意味着我们需要进行大约8.61亿次运算。这是一个相当可行的数字, 现代处理器只需不到0.1秒的时间即可完成。但很明显, 这并不适合扩展:  如果我们的线性方程组中的方程数量是它的20倍(也就是未知数数量是它的20倍), 那么我们就需要花费1000-10000秒, 也就是一个小时的时间。如果线性方程组的数量再增加10倍, 那么很明显, 我们无法在一台计算机上解决更多的问题。

我们可以通过意识到矩阵中只有相对较少的条目为非零, 即矩阵是稀疏的, 来缓解这种情况。高斯消元法的变种可以利用这一点, 使处理过程大大加快；我们将在step-29中首次使用这样一种方法--在SparseDirectUMFPACK类中实现, 以及之后的其他几种方法。高斯消除的这些变化可能会使我们的问题规模达到10万或20万的数量级, 但不会超过这个数量级。

取而代之的是1952年提出的共轭梯度法, 简称 "CG"。CG是一种 "迭代 "求解方法, 它形成的向量序列收敛于精确解；事实上, 在没有舍入误差的情况下, 经过N次这样的迭代后, 如果矩阵是对称和正定的, 它就能找到精确解。该方法最初是作为精确求解线性系统的另一种方法而开发的, 就像高斯消元法一样。但是, 当计算机变得足够强大, 可以解决高斯消元法已经不能很好解决的问题时(20世纪80年代的某个时候), CG被重新发现, 因为人们意识到它非常适合大型稀疏系统, 就像我们从有限元法中得到的系统一样。这是因为: (i)它计算的向量收敛于精确解, 因此我们实际上不必进行$N$次迭代来找到精确解, 只要我们对合理的近似值感到满意即可；(ii)它只需要矩阵-向量乘积, 这对稀疏矩阵非常有用, 因为根据定义, 稀疏矩阵只有$\mathcal{O}(N)$个条目, 因此矩阵-向量乘积只需$\mathcal{O}(N)$次运算即可完成, 而对密集矩阵进行同样的运算则需要$N^2$次运算。因此, 我们希望用最多$\mathcal{O}(N^2)$次运算来求解线性系统, 而且在许多情况下还可以大大减少运算次数。

这些迭代求解器的一个重要组成部分是, 我们指定求解线性系统的容差 - 本质上, 这是我们愿意接受的近似解误差的声明。线性系统$Ax=b$的近似解$\tilde{x}$与精确解$x$的误差定义为$\|x-\tilde{x}\|$, 但这个量我们无法计算, 因为我们不知道精确解$ x $, 相反, 我们通常考虑残差, 定义为$\|b-A\tilde{x}\|=\|A(x-\tilde{x})\|$, 作为一个可计算的度量。然后让迭代求解器计算出越来越精确的解$\tilde{x}$, 直到$\|b-A\tilde{x}\|\le \tau$。一个实际问题是$\tau$的值是多少。在大多数应用中, 设置
$$\tau=10^{-6}\|b\|$$
是一个合理的选择。事实上, $\tau$与$b$的大小(规范)成正比, 这确保了我们对解的精度的期望是相对于解的大小而言的。这是合理的: 如果我们将右边的$b$增大10倍, 那么$Ax=b$的解$x$也将增大10倍, $\tilde{x}$也将增大10倍；我们希望$\tilde{x}$中的精确位数与以前相同, 这意味着当残差$\|b-A\tilde{x}\|$是原始大小的10倍时, 我们也应该终止--这正是我们使$\tau$与$\|b\|$成比例时得到的结果。

所有这些都将在本程序的Step3::solve()函数中实现。正如你所看到的, 使用deal.II建立线性求解器非常简单: 整个函数只有三行。
\subsection{关于实现}
虽然这是用有限元方法求解的最简单方程, 但这个程序显示了大多数有限元程序的基本结构, 也是几乎所有后续程序的模板。具体而言, 本程序的主类如下: 
\lstset{language=C++}
\begin{lstlisting}
class Step3
{
  public:
    Step3 ();
    void run ();
 
  private:
    void make_grid ();
    void setup_system ();
    void assemble_system ();
    void solve ();
    void output_results () const;
 
    Triangulation<2>     triangulation;
    FE_Q<2>              fe;
    DoFHandler<2>        dof_handler;
 
    SparsityPattern      sparsity_pattern;
    SparseMatrix<double> system_matrix;
    Vector<double>       solution;
    Vector<double>       system_rhs;
};
\end{lstlisting}
这遵循了面向对象编程的数据封装原则, 即尽最大努力将该类的几乎所有内部细节隐藏在外部无法访问的私有成员中。

让我们从成员变量开始: 我们需要一个Triangulation对象和一个DoFHandler对象, 以及一个描述我们希望使用的形状函数的有限元对象。第二组对象与线性代数有关: 系统矩阵和右边以及解向量,
 还有一个描述矩阵稀疏性模式的对象。这就是该类所需要的全部内容(也是任何静态PDE求解器所需要的基本内容), 并且需要在整个程序中保持不变。与此相反, 我们在装配时需要的FEValues对象只在整个装配过程中需要, 因此我们在函数中将其创建为局部对象, 并在函数结束时将其销毁。

其次, 让我们看看成员函数。这些函数已经构成了几乎所有后续教程程序都将使用的通用结构: 
\begin{itemize}
    \item[$\bullet$]make\_grid(): 这就是所谓的预处理函数。顾名思义, 它设置了存储三角剖分的对象。在后面的示例中, 它还可以处理边界条件、几何形状等。
    \item[$\bullet$]setup\_system(): 在这个函数中, 所有其他数据结构都被设置为解决问题所需的数据结构。特别是, 它将初始化DoFHandler对象, 并正确设置与线性代数有关的各种对象的大小。这个函数通常与上面的预处理函数分开, 因为在一个与时间相关的程序中, 每当网格进行自适应细化时, 至少每隔几个时间步就会调用这个函数(我们将在step-6中了解如何进行细化)。另一方面, 上述预处理函数中的网格设置只在程序开始时进行一次, 因此可以将其独立出来。
    \item[$\bullet$]assemble\_system(): 这就是计算矩阵和右边内容的地方, 在上面的介绍中已经详细讨论过。由于对该线性系统的处理在概念上与计算其条目截然不同, 因此我们将其与下面的函数分开。
    \item[$\bullet$]solve(): 这就是计算线性系统 $AU=F$ 的解 $U$ 的函数。在当前程序中, 这是一个简单的任务, 因为矩阵非常简单, 但当问题不再那么琐碎时, 它将成为程序大小的重要部分(例如, 当你对函数库有了更多了解后, 请参见step-20、step-22或step-31)  
    \item[$\bullet$]output\_results(): 最后, 当你计算出一个解决方案后, 你可能想对其进行一些处理。例如, 你可能希望将其输出为可视化格式, 或者你可能希望计算你感兴趣的数量: 例如, 热交换器中的热通量、机翼的空气摩擦系数、最大桥梁载荷, 或者仅仅是数值解在某一点的值。因此, 该函数用于对求解结果进行后处理。
\end{itemize}
所有这些都由一个公共函数(构造函数除外), 即run()函数来完成。从创建该类型对象的地方调用该函数, 并按正确顺序调用所有其他函数。将这一操作封装到run()函数中, 而不是从main()函数调用所有其他函数, 可以确保您可以改变该类中关注点分离的实现方式。例如, 如果其中一个函数变得过大, 您可以将其拆分为两个函数, 而您唯一需要关注的地方就是这个类内部, 而不是其他任何地方。

如上所述, 您将在下面的许多教程程序中再次看到这种一般结构--有时函数名称的拼写会有变化, 但基本上是按照这种顺序分离功能的。

\subsection{关于类型的说明}
deal.II通过命名空间类型中的别名定义了许多积分类型。(在前面的句子中, "积分 "一词是作为形容词使用的, 与名词 "整数 "相对应。它不应与表示曲线或曲面下的面积或体积的名词 "积分 "相混淆。形容词 "integral "在C++世界中被广泛使用, 例如 "integral type"(积分类型)、"integral constant"(积分常数)等)。特别地, 在这个程序中, 你会在几个地方看到types::global\_dof\_index: 一个整数类型, 用来表示一个自由度的全局索引, 也就是在三角剖分上定义的DoFHandler对象中特定自由度的索引(与特定单元格中特定自由度的索引相反)。对于当前程序(以及几乎所有的教程程序), 您将会有几千到几百万个全局未知数(对于Q1元素, 您将会在2D中的每个单元格上有4个局部未知数, 在3D中则有8个)。因此, 无符号int是一种可以存储足够大的全局DoF指数的数据类型, 因为它可以存储0到略高于40亿之间的数字(在大多数系统中, 整数是32位的)。事实上, 这就是 types::global\_dof\_index 的用途。

那么, 为什么不直接使用无符号int呢？deal.II在7.3版本之前一直这样做。然而, deal.II支持非常大的计算(通过step-40讨论的框架), 当分布在几千个处理器上时, 可能有超过40亿个未知数。因此, 在某些情况下, 无符号int不够大, 我们需要64位无符号积分类型。为了实现这一点, 我们引入了 types::global\_dof\_index, 它默认定义为无符号 int, 但如果需要, 也可以通过在配置时传递一个特定标志(参见 ReadMe 文件), 将其定义为无符号 long int。

这涵盖了技术方面。但是还有一个文档目的: 在库中的任何地方, 以及基于库的代码中, 如果你看到一个地方使用了数据类型 types::global\_dof\_index, 你就会立即知道被引用的量实际上是一个全局的 dof 索引。如果我们只是使用无符号int(也可能是局部索引、边界指示器、材料id等), 就不会有这样的含义。立即知道一个变量指的是什么也有助于避免错误: 很明显, 如果你看到一个 type::global\_dof\_index 类型的对象被赋值给 type::subdomain\_id 类型的变量, 这一定是个错误, 尽管它们都是由无符号整数表示的, 编译器因此不会抱怨。

在更实际的情况下, 这种类型的存在意味着在装配过程中, 我们创建一个
的矩阵(在2d中, 使用$Q_1$元素)来表示我们当前所处的单元的贡献, 然后我们需要将这个矩阵的元素添加到全局(系统)矩阵的适当元素中。为此, 我们需要获取当前单元的局部自由度的全局索引, 为此我们将始终使用下面这段代码: 
\lstset{language=C++}
\begin{lstlisting}
cell->get_dof_indices (local_dof_indices);
\end{lstlisting}
其中 local\_dof\_indices 被声明为
\lstset{language=C++}
\begin{lstlisting}
std::vector<types::global_dof_index> 
local_dof_indices (fe.n_dofs_per_cell());
\end{lstlisting}
这个变量的名字可能有点名不副实--它的意思是 "当前单元格中局部定义的自由度的全局指数"--但是在整个库中, 包含这些信息的变量都被统一以这种方式命名。
\section{运行结果}
运行示例中的这段代码，可以得到如下图像
    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{./imag/solution.eps}
    \caption{二维拉普拉斯方程解}
    \end{figure}
\\    
该示例计算了一个膜受到受到外部（垂直的）力时的垂直变形数据，膜的边界被夹在一个没有垂直变化的方形框架上。参数如下所示：
\lstset{language=C}
\begin{lstlisting}
Number of active cells: 1024
Number of degrees of freedom: 1089
DEAL:cg::Starting value 0.121094
DEAL:cg::Convergence step 36 value 7.07761e-08
\end{lstlisting}
\end{document}
